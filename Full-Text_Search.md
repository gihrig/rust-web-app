### Comparison of Full-Text Search Features: PostgreSQL vs. SQLite

For a medium-sized eCommerce application with fewer than 10,000 visitors per month, both PostgreSQL and SQLite can handle full-text search needs effectively, such as querying product names, descriptions, and categories. The low traffic volume means performance differences are minimal, but PostgreSQL offers more advanced linguistic and ranking capabilities, making it better for growing or multilingual apps. SQLite (via its FTS5 extension) is lighter and simpler, ideal for embedded or resource-constrained setups. Below is a detailed feature comparison.

| Feature                 | PostgreSQL                                                                                                                                                                                                                                                                    | SQLite (FTS5 Extension)                                                                                                                                                                                                                                                               |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Indexing**            | Uses GIN (preferred, inverted index for fast lookups) or GiST (tree-based, flexible but potentially lossy) on `tsvector` columns. Supports generated columns or triggers for automatic updates. Handles large datasets with partitioning if needed.                           | Creates virtual tables with shadow tables for indexing tokens. Supports prefix indexes, detail levels (full for precision, none for space savings), contentless/external content modes to reduce storage.                                                                             |
| **Querying**            | Advanced with `tsquery` types (e.g., `to_tsquery`, `phraseto_tsquery`, `websearch_to_tsquery`). Operators like `@@` for matching, `&` (AND), `                                                                                                                                | ` (OR), `!` (NOT), `<->` for proximity/phrase searches. Linguistic parsing skips stop words and handles variants.                                                                                                                                                                     | Uses `MATCH` operator or table-valued syntax. Supports phrases (`""`), prefixes (`*`), `NEAR` for proximity, boolean (`AND`, `OR`, `NOT`), and column filters (e.g., `category:electronics`). Flexible but less linguistic depth. |
| **Ranking**             | Built-in `ts_rank` and `ts_rank_cd` functions for relevance based on frequency, proximity, and weights (A-D levels for fields like title vs. description). Can sort results by relevance.                                                                                     | `bm25()` function and hidden `rank` column for relevance scoring. Supports column weighting (e.g., higher for product names). Efficient but simpler than PostgreSQL's proximity-aware ranking.                                                                                        |
| **Supported Languages** | Extensive built-in configurations for many languages (e.g., English, French, Spanish) via dictionaries for stemming, synonyms, thesaurus, and stop words. Custom dictionaries possible; strong multilingual support.                                                          | Tokenizers include `unicode61` (default, case-insensitive with diacritics removal), `porter` (English stemming), `ascii`, `trigram` (substring matching). Locale support and custom tokenizers, but limited advanced linguistics (no ICU; weaker for non-Latin scripts like Chinese). |
| **Limitations**         | No native typo tolerance or fuzzy matching (requires extensions like `pg_trgm` for trigram similarity). GiST indexes may require rechecks for false matches. Scales well but may need tuning/partitioning for massive data; not ideal for ultra-high-traffic without add-ons. | Default case-insensitivity limits exact matches. Reduced detail modes disable features like `NEAR`/phrases. Contentless tables restrict updates/deletes. Slower for short keywords or prefix tokens; no built-in highlighting or advanced synonyms.                                   |
| **Suitability for App** | Excellent for eCommerce needing advanced features like multilingual stemming, weighted ranking across fields (e.g., prioritizing product titles), and future scalability. Handles concurrency well for growing user bases.                                                    | Good for simpler setups with low overhead; sufficient for basic keyword/phrase searches in English-dominant apps. Easier to embed in apps, but may require more custom work for complex queries or languages.                                                                         |
