# Connecting a Leptos Frontend to an Axum Backend

Generated by Grok 3 > "How can I connect a leptos project to a separate Rust/Axum backend?"

Connecting a **Leptos** frontend to a separate **Axum** backend in Rust involves setting up a full-stack application where Leptos handles the frontend (client-side rendering, server-side rendering, or hydration) and Axum serves as the backend API. Below is a step-by-step guide to achieve this integration, leveraging Leptos' server functions and Axum's routing capabilities. This assumes you want a separate Axum backend to handle API requests while Leptos manages the UI.

---

## 1. Project Setup
To start, create a new Rust project with both Leptos and Axum dependencies. The recommended approach is to use the `cargo-leptos` tool to streamline the setup for a full-stack Leptos project with Axum as the backend.

### Steps:
1. **Install Prerequisites**:
   - Ensure Rust is installed and up-to-date (`rustup update`).
   - Install `cargo-leptos` for building Leptos projects:
     ```bash
     cargo install cargo-leptos
     ```
   - Install nightly Rust and WebAssembly target:
     ```bash
     rustup toolchain install nightly --allow-downgrade
     rustup target add wasm32-unknown-unknown
     ```

2. **Create a New Leptos Project**:
   Use the `leptos-rs/start-axum` template to set up a project with Leptos and Axum:
   ```bash
   cargo leptos new --git https://github.com/leptos-rs/start-axum
   cd your_project_name
   ```
   This creates a project structure with separate server and client code, using Axum as the backend.

3. **Project Structure**:
   The generated project typically looks like this:
   ```
   your_project_name/
   ├── Cargo.toml
   ├── src/
   │   ├── app.rs         # Leptos frontend code
   │   ├── lib.rs         # Frontend entry point
   │   ├── main.rs        # Axum server entry point
   │   └── error_template.rs  # Error handling
   ├── style/             # CSS/Tailwind files
   └── target/            # Build outputs
   ```
   - `src/main.rs`: Contains the Axum server setup.
   - `src/app.rs`: Defines the Leptos frontend components.
   - `Cargo.toml`: Includes dependencies for Leptos, Axum, and `leptos_axum`.

4. **Update Dependencies**:
   Ensure your `Cargo.toml` includes the necessary dependencies. A minimal example:
   ```toml
   [package]
   name = "your_project_name"
   version = "0.1.0"
   edition = "2021"

   [dependencies]
   axum = { version = "0.7", features = ["default"] }
   leptos = { version = "0.7", features = ["csr", "nightly"] }
   leptos_axum = { version = "0.7" }
   leptos_meta = { version = "0.7" }
   leptos_router = { version = "0.7" }
   tokio = { version = "1", features = ["full"] }
   tower-http = { version = "0.5", features = ["fs"] }
   serde = { version = "1", features = ["derive"] }
   wasm-bindgen = "0.2"

   [dev-dependencies]
   cargo-leptos = "0.2"
   ```
   - Use `leptos` with the `csr` feature for client-side rendering or `ssr` for server-side rendering, depending on your needs.
   - `leptos_axum` provides integration utilities for Leptos and Axum.

---

## 2. Configure the Axum Backend
The Axum backend will handle API routes and serve Leptos' server functions. The `leptos_axum` crate simplifies this by providing utilities to integrate Leptos server functions with Axum's routing.

### Steps:
1. **Set Up the Axum Server** (`src/main.rs`):
   Modify the main server file to set up Axum routes and integrate Leptos. Here's an example:
   ```rust
   use axum::{Router, routing::{get, post}};
   use leptos::*;
   use leptos_axum::{generate_route_list, LeptosRoutes, handle_server_fns};
   use your_project_name::app::App; // Your Leptos root component
   use tower_http::services::ServeDir;
   use std::sync::Arc;

   #[tokio::main]
   async fn main() {
       // Initialize Leptos options
       let conf = get_configuration(None).expect("Failed to load configuration");
       let addr = conf.leptos_options.site_addr;

       // Generate the list of Leptos routes
       let routes = generate_route_list(App);

       // Define Axum router
       let app = Router::new()
           // Serve static files (e.g., CSS, JS, WASM)
           .nest_service("/pkg", ServeDir::new("target/site/pkg"))
           // Handle Leptos server functions at /api
           .route("/api/*fn_name", post(handle_server_fns))
           // Leptos routes for client-side navigation
           .leptos_routes(&conf.leptos_options, routes, App)
           // Add custom API routes
           .route("/api/custom", get(custom_api_handler))
           // Shared state (optional, for AppState)
           .with_state(Arc::new(conf.leptos_options));

       // Start the server
       let listener = tokio::net::TcpListener::bind(&addr).await.unwrap();
       axum::serve(listener, app.into_make_service()).await.unwrap();
   }

   // Example custom API handler
   async fn custom_api_handler() -> axum::Json<serde_json::Value> {
       axum::Json(serde_json::json!({"message": "Hello from Axum!"}))
   }
   ```
   - `generate_route_list(App)`: Automatically generates Leptos routes from your `App` component.
   - `leptos_routes`: Registers Leptos routes with Axum.
   - `handle_server_fns`: Handles Leptos server functions at the `/api/*fn_name` endpoint.
   - `ServeDir`: Serves static files (e.g., WebAssembly, CSS) from `target/site/pkg`.

2. **Add Custom API Routes**:
   You can add custom Axum routes for your backend logic. For example, the `/api/custom` route above returns a JSON response. You can extend this to handle database queries, authentication, or other backend tasks.

3. **Shared State (Optional)**:
   If your backend needs shared state (e.g., a database connection pool), define an `AppState` struct and pass it to Axum:
   ```rust
   #[derive(Clone)]
   struct AppState {
       db: sqlx::Pool<sqlx::Sqlite>,
   }

   async fn custom_api_handler(state: axum::extract::State<Arc<AppState>>) -> axum::Json<serde_json::Value> {
       // Use state.db for database queries
       axum::Json(serde_json::json!({"message": "Database access"}))
   }

   // In main.rs
   let state = Arc::new(AppState {
       db: sqlx::SqlitePool::connect("sqlite::memory:").await.unwrap(),
   });
   let app = Router::new()
       .route("/api/custom", get(custom_api_handler))
       .with_state(state);
   ```

---

## 3. Define Leptos Server Functions
Leptos server functions allow you to call backend logic from the frontend as if it were a local function, abstracting away the need to manually define REST API endpoints.

### Steps:
1. **Create a Server Function**:
   Define a server function in a separate file, e.g., `src/server.rs`:
   ```rust
   use leptos::*;
   use serde::{Deserialize, Serialize};

   #[derive(Serialize, Deserialize)]
   struct MyData {
       value: String,
   }

   #[server(GetData, "/api")]
   pub async fn get_data() -> Result<MyData, ServerFnError> {
       // Simulate backend logic (e.g., database query)
       Ok(MyData {
           value: "Data from Axum backend".to_string(),
       })
   }
   ```
   - The `#[server(GetData, "/api")]` macro registers the function to be handled at `/api/get_data`.
   - The function runs on the server but can be called from the client.

2. **Register Server Functions**:
   In `src/main.rs`, ensure server functions are registered with Axum:
   ```rust
   use your_project_name::server::get_data; // Import the server function

   let app = Router::new()
       .route("/api/*fn_name", post(handle_server_fns))
       .with_state(Arc::new(conf.leptos_options));
   ```
   The `handle_server_fns` function from `leptos_axum` automatically routes server function requests.

3. **Access AppState in Server Functions** (Optional):
   If you need to access shared state (e.g., a database pool) in server functions, use `leptos::use_context`:
   ```rust
   #[server(GetDataWithState, "/api")]
   pub async fn get_data_with_state() -> Result<MyData, ServerFnError> {
       let state = use_context::<Arc<AppState>>().ok_or(ServerFnError::ServerError("No AppState".to_string()))?;
       // Use state.db for database queries
       Ok(MyData {
           value: "Data from Axum with state".to_string(),
       })
   }
   ```
   Ensure the `AppState` is provided in the Axum router's state:
   ```rust
   let app = Router::new()
       .route("/api/*fn_name", post(handle_server_fns))
       .with_state(Arc::new(AppState { db: /* ... */ }));
   ```

---

## 4. Build the Leptos Frontend
In the Leptos frontend, you can call server functions or custom Axum API endpoints from your components.

### Steps:
1. **Create the Frontend Component** (`src/app.rs`):
   Define a Leptos component that calls the server function or API:
   ```rust
   use leptos::*;
   use crate::server::get_data;

   #[component]
   pub fn App() -> impl IntoView {
       // Create a resource to fetch data reactively
       let data = create_resource(|| (), |_| async move {
           get_data().await.unwrap_or(MyData {
               value: "Error fetching data".to_string(),
           })
       });

       view! {
           <h1>"Leptos with Axum"</h1>
           <Suspense fallback=|| view! { <p>"Loading..."</p> }>
               {move || data.get().map(|data| view! {
                   <p>"Data: " {data.value}</p>
               })}
           </Suspense>
       }
   }
   ```
   - `create_resource` fetches the server function data asynchronously.
   - `<Suspense>` handles loading states while data is being fetched.

2. **Call Custom Axum Endpoints** (Optional):
   If you want to call a custom Axum endpoint (e.g., `/api/custom`), use `leptos::create_resource` with an HTTP client like `reqwest`:
   ```rust
   use leptos::*;
   use reqwest::Client;
   use serde_json::Value;

   #[component]
   pub fn CustomApiComponent() -> impl IntoView {
       let data = create_resource(|| (), |_| async move {
           let client = Client::new();
           let res = client.get("http://127.0.0.1:3000/api/custom")
               .send()
               .await
               .unwrap()
               .json::<Value>()
               .await
               .unwrap();
           res
       });

       view! {
           <h1>"Custom API Call"</h1>
           <Suspense fallback=|| view! { <p>"Loading..."</p> }>
               {move || data.get().map(|data| view! {
                   <p>"API Response: " {format!("{:?}", data)}</p>
               })}
           </Suspense>
       }
   }
   ```

---

## 5. Build and Run the Application
1. **Build the Project**:
   Use `cargo-leptos` to compile both the server and client:
   ```bash
   cargo leptos watch
   ```
   - This command builds the server (Axum) and client (Leptos WASM) and serves them at `http://127.0.0.1:3000`.
   - It also enables hot-reloading for development.

2. **Access the App**:
   Open `http://127.0.0.1:3000` in your browser. The Leptos frontend will render, and it will communicate with the Axum backend via server functions or custom API routes.

---

## 6. Additional Considerations
- **Server-Side Rendering (SSR)**:
  If you want SSR, enable the `ssr` feature in `leptos` and use `leptos_axum::render_app_to_stream` in your Axum router. Update `Cargo.toml`:
  ```toml
  leptos = { version = "0.7", features = ["ssr", "nightly"] }
  ```
  Modify `src/main.rs` to use SSR:
  ```rust
  let app = Router::new()
      .leptos_routes_with_handler(&conf.leptos_options, routes, |cx| view! { cx, <App/> })
      .route("/api/*fn_name", post(handle_server_fns))
      .nest_service("/pkg", ServeDir::new("target/site/pkg"))
      .with_state(Arc::new(conf.leptos_options));
  ```

- **Database Integration**:
  For a database, use crates like `sqlx` or `sea-orm`. Initialize a connection pool in `AppState` and access it in server functions or custom Axum handlers. Example with `sqlx`:
  ```rust
  let pool = sqlx::SqlitePool::connect("sqlite://database.db").await.unwrap();
  let state = Arc::new(AppState { db: pool });
  ```

- **Error Handling**:
  Use `ServerFnError` for server functions and Axum's error handling for custom routes. Include an error template (`src/error_template.rs`) for user-friendly error pages.

- **CORS**:
  If the frontend and backend are on different domains, add CORS support to Axum using `tower-http`:
  ```toml
  tower-http = { version = "0.5", features = ["cors"] }
  ```
  ```rust
  use tower_http::cors::CorsLayer;

  let app = Router::new()
      .layer(CorsLayer::permissive())
      .route("/api/*fn_name", post(handle_server_fns));
  ```

- **Troubleshooting**:
  - Ensure `wasm-bindgen` versions match between your project and `cargo-leptos` to avoid compilation errors. Update with:
    ```bash
    cargo update -p wasm-bindgen --precise 0.2.86
    ```
  - Check the Leptos Discord or GitHub issues for community support.

---

## 7. Example Workflow
- **Frontend**: A Leptos component in `src/app.rs` calls `get_data` (a server function) to fetch data from the Axum backend.
- **Backend**: The Axum server in `src/main.rs` handles the `/api/get_data` request and returns a JSON response.
- **Communication**: Server functions abstract the HTTP layer, but you can also use RESTful endpoints (`/api/custom`) for custom logic.
- **Build**: `cargo leptos watch` compiles and serves both the frontend (WASM) and backend (Axum).

---

## Resources
- **Leptos Book**: Detailed guide on Leptos and Axum integration (https://book.leptos.dev).
- **Leptos Axum Starter Template**: GitHub repository with a working example (https://github.com/leptos-rs/start-axum).
- **Leptos Discord**: Community support for troubleshooting (linked in the Leptos Book).
- **Axum Documentation**: For advanced backend routing and middleware (https://docs.rs/axum).

This setup allows you to leverage Leptos' reactive frontend with Axum's performant backend, keeping everything in Rust for type safety and performance. If you need a more specific example (e.g., database integration or authentication), let me know!
